# Sem√°foro Inteligente com Acessibilidade e Modo Noturno usando FreeRTOS na BitDogLab

## √çndice

- [Sem√°foro Inteligente com Acessibilidade e Modo Noturno usando FreeRTOS na BitDogLab](#sem√°foro-inteligente-com-acessibilidade-e-modo-noturno-usando-freertos-na-bitdoglab)
  - [√çndice](#√≠ndice)
  - [Objetivos](#objetivos)
  - [Descri√ß√£o do Projeto](#descri√ß√£o-do-projeto)
  - [Funcionalidades Implementadas](#funcionalidades-implementadas)
  - [Requisitos T√©cnicos Atendidos](#requisitos-t√©cnicos-atendidos)
  - [Como Executar](#como-executar)
    - [Requisitos de Hardware](#requisitos-de-hardware)
    - [Requisitos de Software](#requisitos-de-software)
    - [Passos](#passos)
  - [Estrutura do C√≥digo](#estrutura-do-c√≥digo)
  - [Demonstrativo em V√≠deo](#demonstrativo-em-v√≠deo)

## Objetivos

*   Aplicar os conceitos de Sistemas Operacionais de Tempo Real (RTOS), especificamente FreeRTOS, em um microcontrolador RP2040.
*   Desenvolver um sistema multitarefa real, com tarefas dedicadas ao controle de perif√©ricos e √† l√≥gica principal.
*   Implementar um sem√°foro de cruzamento funcional com ciclos para ve√≠culos e pedestres.
*   Criar um modo de opera√ß√£o noturno com comportamento de alerta distinto.
*   Integrar m√∫ltiplos perif√©ricos da placa BitDogLab: GPIO (LEDs, Bot√µes com IRQ), PIO (Matriz de LEDs WS2812), I2C (Display OLED SSD1306) e PWM (Buzzer).
*   Implementar recursos de acessibilidade atrav√©s de feedback sonoro distinto para cada fase do sem√°foro, utilizando o buzzer.
*   Gerenciar a comunica√ß√£o e sincroniza√ß√£o entre tarefas utilizando *apenas* vari√°veis globais vol√°teis (conforme requisito espec√≠fico), com prote√ß√£o b√°sica via se√ß√µes cr√≠ticas.
*   Desenvolver o projeto em um ambiente VS Code configurado para o RP2040 com c√≥digo modularizado e comentado.

## Descri√ß√£o do Projeto

Este projeto implementa um "Sem√°foro Inteligente" na placa BitDogLab usando o RP2040 e o sistema operacional de tempo real FreeRTOS. O sistema simula um cruzamento gerenciando o fluxo de ve√≠culos e pedestres com dois modos de opera√ß√£o principais: Normal e Noturno.

**Modo Normal:**
*   **Ve√≠culos:** O sem√°foro para ve√≠culos, representado pelos LEDs RGB (pinos Vermelho, Verde, Azul/Amarelo), segue o ciclo padr√£o: Verde -> Amarelo -> Vermelho -> Vermelho+Amarelo -> Verde.
*   **Pedestres:** O sem√°foro para pedestres, representado pela Matriz de LEDs 5x5 WS2812 (controlada via PIO), √© sincronizado com o sem√°foro de ve√≠culos:
    *   Exibe um s√≠mbolo de "Pare" (m√£o/bloco vermelho) quando os ve√≠culos t√™m sinal verde ou amarelo.
    *   Exibe um s√≠mbolo de "Ande" (boneco verde) por um per√≠odo quando os ve√≠culos est√£o com sinal vermelho.
    *   Exibe o s√≠mbolo de "Pare" piscando por um per√≠odo antes de liberar os ve√≠culos novamente.
*   **Acessibilidade Sonora:** O buzzer emite padr√µes sonoros distintos para indicar a fase do pedestre (som cont√≠nuo para "Ande", bipes r√°pidos para "Pare" piscando).

**Modo Noturno:**
*   **Ve√≠culos:** O sem√°foro para ve√≠culos exibe apenas a luz Amarela (usando pino Azul) piscando intermitentemente.
*   **Pedestres:** A matriz de LEDs para pedestres permanece apagada.
*   **Acessibilidade Sonora:** O buzzer emite um bip lento e espa√ßado indicando o modo noturno de alerta.

**Controle e Feedback:**
*   O **Bot√£o A** √© usado para alternar entre os modos Normal e Noturno, com detec√ß√£o via interrup√ß√£o (IRQ) e tratamento de debounce.
*   O **Display OLED** (128x64, via I2C) exibe o modo de opera√ß√£o atual ("NORMAL" ou "NOTURNO") e o estado detalhado da fase do cruzamento (ex: "Carro: Verde / Ped:Pare"). *(Nota: A funcionalidade do display est√° presente no c√≥digo, mas pode ser comentada para testes individuais das outras tarefas).*
*   Logs de inicializa√ß√£o e mudan√ßa de modo s√£o enviados via `printf` (vis√≠vel em terminal serial USB).

**Arquitetura FreeRTOS:**
O sistema utiliza m√∫ltiplas tarefas FreeRTOS, cada uma respons√°vel por um perif√©rico ou pela l√≥gica central:
*   `vIntersectionControllerTask`: Gerencia as fases do sem√°foro e a temporiza√ß√£o principal.
*   `vButtonTask`: Monitora o Bot√£o A para mudan√ßa de modo.
*   `vRgbLedTask`: Controla o LED RGB (sem√°foro de ve√≠culos).
*   `vLedMatrixTask`: Controla a Matriz de LEDs (sem√°foro de pedestres).
*   `vBuzzerTask`: Gera os sons de acessibilidade.
*   `vDisplayTask`: Atualiza o display OLED (se habilitado).

## Funcionalidades Implementadas

```
‚úÖ Ciclo de sem√°foro para ve√≠culos (Verde -> Amarelo -> Vermelho -> Vermelho+Amarelo) usando LEDs RGB/individuais.
‚úÖ Ciclo de sem√°foro para pedestres (Ande -> Pare Piscando -> Pare) usando Matriz de LEDs WS2812 (via PIO).
‚úÖ Sincroniza√ß√£o entre os ciclos de ve√≠culos e pedestres.
‚úÖ Implementa√ß√£o de Modo Noturno (Amarelo piscante para ve√≠culos, matriz apagada, som lento).
‚úÖ Leitura do Bot√£o A (GPIO 5) via Interrup√ß√£o (IRQ) com Debounce para alternar entre Modo Normal e Noturno.
‚úÖ Uso de flag global vol√°til (`g_flagModoNoturno`, `g_intersectionPhase`) para comunica√ß√£o entre tarefas (conforme restri√ß√£o).
‚úÖ Prote√ß√£o b√°sica de acesso √†s flags globais com `taskENTER/EXIT_CRITICAL()`.
‚úÖ Gera√ß√£o de sons distintos no buzzer (via PWM) para fases de pedestre ("Ande", "Pare Piscando") e Modo Noturno.
‚úÖ Exibi√ß√£o do modo e estado atual no display OLED SSD1306 (I2C). *(Funcionalidade comentada na vers√£o de teste)*.
‚úÖ Uso de m√∫ltiplas tarefas FreeRTOS dedicadas (Controller, Button, RGB LED, Matrix, Buzzer, Display).
‚úÖ C√≥digo estruturado em m√≥dulos (`main.c`, `hardware_management/` para drivers/config) e comentado.
‚úÖ Mensagens de log de inicializa√ß√£o e mudan√ßa de modo via `printf` (stdio/USB).
```

## Requisitos T√©cnicos Atendidos

*(Baseado nos requisitos originais do projeto de Sem√°foro)*

1.  **Implementar Sem√°foro Inteligente:** Sim, implementa a l√≥gica com dois modos.
2.  **Dois Modos Distintos:** Sim, Normal e Noturno com comportamentos diferentes.
3.  **Utilizar Apenas Tarefas FreeRTOS:** Sim, a l√≥gica √© distribu√≠da em m√∫ltiplas tarefas. (Nota: Bot√µes usam ISR para detec√ß√£o inicial).
4.  **Sem Filas, Sem√°foros ou Mutexes:** Sim, a comunica√ß√£o principal √© via flags globais vol√°teis. (Nota: `taskENTER/EXIT_CRITICAL` usado para prote√ß√£o m√≠nima).
5.  **Representado por:**
    *   **Matriz de LEDs:** Sim, usada para pedestres (Walk/Don't Walk piscando).
    *   **LED RGB:** Sim, usado para sem√°foro de ve√≠culos (R/G/Y).
    *   **Display:** Sim, exibe modo/estado (pode ser comentado para teste).
    *   **Buzzer:** Sim, usado para feedback sonoro de acessibilidade.
6.  **Modo Normal:** Sim, implementa o ciclo Veicular e Pedestre com sons correspondentes.
7.  **Modo Noturno:** Sim, implementa Amarelo piscante (veicular) e som lento, com matriz apagada.
8.  **Alternar com Bot√£o A:** Sim, implementado com IRQ, debounce e flag global.
9.  **Flag Global Modificada por Tarefa:** Sim, `g_flagModoNoturno` (pela ButtonTask) e `TrafficLight_states trafficLight_state` (pela ControllerTask).
10. **Sinais Sonoros Distintos:** Sim, padr√µes diferentes para Pedestre Anda, Pedestre Pisca e Modo Noturno.
11. **Requisito Impl√≠cito (Task por Perif√©rico):** Sim, a estrutura final dedica tarefas para Bot√£o, LED RGB, Matriz, Buzzer, Display, al√©m da tarefa Controladora.

## Como Executar

### Requisitos de Hardware

*   Placa de desenvolvimento **BitDogLab** (com RP2040).
*   Cabo Micro-USB para conex√£o e alimenta√ß√£o/programa√ß√£o.

### Requisitos de Software

*   **VS Code** com a extens√£o Pico-W-Go ou configura√ß√£o manual do toolchain ARM e Pico SDK.
*   **Pico SDK** vers√£o compat√≠vel instalada e configurada (ex: 1.5.1+).
*   **FreeRTOS Kernel:** O c√≥digo assume que o diret√≥rio `FreeRTOS-Kernel` existe na raiz do projeto (idealmente como um subm√≥dulo git: `git submodule update --init`).
*   **Git** (opcional, para clonar).
*   Um **Terminal Serial** (ex: Monitor Serial do VS Code, Putty, Minicom) configurado para a porta serial da Pico e **115200 baud** (verifique `pico_enable_stdio_uart` / `usb` no CMakeLists e a configura√ß√£o em `pico/stdlib.h` se usar baudrate diferente).

### Passos

1.  **Obter o C√≥digo:** Clone ou baixe o reposit√≥rio/arquivos do projeto.
2.  **Obter FreeRTOS:** Se ainda n√£o tiver, inicialize o subm√≥dulo:
    ```bash
    git submodule update --init --recursive
    ```
    Ou copie manualmente a pasta `FreeRTOS-Kernel` para a raiz do projeto.
3.  **Configurar o Projeto (CMakeLists.txt):**
    *   Verifique o caminho para `FREERTOS_KERNEL_PATH` no `CMakeLists.txt` e ajuste se necess√°rio (o padr√£o assume estar na raiz).
    *   Certifique-se de que `PICO_BOARD` est√° definido corretamente (provavelmente `pico_w`).
4.  **Compilar (Build):**
    *   Via VS Code: Use a fun√ß√£o de build.
    *   Via Linha de Comando:
        ```bash
        mkdir build
        cd build
        cmake ..
        make
        ```
5.  **Carregar o Firmware:**
    *   Coloque a BitDogLab em modo BOOTSEL (pressione BOOTSEL ao conectar o USB).
    *   Copie o arquivo `main.uf2` (ou o nome do seu projeto `.uf2`) da pasta `build` para o drive `RPI-RP2`.
    *   A placa reiniciar√°.
6.  **Visualizar Logs:** Abra o terminal serial na porta COM correta com 115200 baud.
7.  **Testar:**
    *   Observe o comportamento dos LEDs RGB e da Matriz de LEDs.
    *   Ou√ßa os padr√µes do buzzer.
    *   Pressione o Bot√£o A (GPIO 5) para alternar entre os modos Normal e Noturno.
    *   *(Se habilitado)* Observe as informa√ß√µes no display OLED.

## Estrutura do C√≥digo

```
üìÇ src/
‚îú‚îÄ‚îÄ include/ # Headers p√∫blicos
‚îÇ ‚îî‚îÄ‚îÄ hardware_management/ # Headers dos m√≥dulos de hardware
| |   FreeRTOSConfig.h # Configura√ß√£o espec√≠fica do FreeRTOS
‚îÇ ‚îú‚îÄ‚îÄ buttons.h
‚îÇ ‚îú‚îÄ‚îÄ buzzer.h
‚îÇ ‚îú‚îÄ‚îÄ debouncer.h
‚îÇ ‚îú‚îÄ‚îÄ display.h
‚îÇ ‚îú‚îÄ‚îÄ led_matrix.h
‚îÇ ‚îî‚îÄ‚îÄ hardware_config.h # Configura√ß√£o centralizada de pinos/constantes
‚îÇ ‚îú‚îÄ‚îÄ hardware_management/ # Implementa√ß√£o dos m√≥dulos de hardware
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ buttons.c
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ buzzer.c
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ debouncer.c
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ display.c # Cont√©m init/startup (Task comentada aqui)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ led_matrix.c
‚îÇ ‚îî‚îÄ‚îÄ main.c # Ponto de entrada, init, cria√ß√£o de tasks, loop tasks
‚îú‚îÄ‚îÄ pio/ # Programas PIO Assembly
‚îÇ ‚îî‚îÄ‚îÄ led_matrix.pio
‚îú‚îÄ‚îÄ lib/ # Bibliotecas
‚îÇ ‚îî‚îÄ‚îÄ ssd1306/
‚îÇ ‚îú‚îÄ‚îÄ ssd1306.c
‚îÇ ‚îú‚îÄ‚îÄ ssd1306.h
‚îÇ ‚îî‚îÄ‚îÄ font.h # (se separado)
‚îú‚îÄ‚îÄ CMakeLists.txt # Configura√ß√£o do build CMake
‚îú‚îÄ‚îÄ pico_sdk_import.cmake # Padr√£o do SDK
```

## Demonstrativo em V√≠deo

*(Insira aqui o link para um v√≠deo demonstrando o projeto funcionando, se dispon√≠vel)*
